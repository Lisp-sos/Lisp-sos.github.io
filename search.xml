<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Stm32之SPI</title>
      <link href="/cm6s8szdk0000lgt4c02tdfmd.html"/>
      <url>/cm6s8szdk0000lgt4c02tdfmd.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stm32之I2C</title>
      <link href="/cm6s8szdz0001lgt40msjbqsi.html"/>
      <url>/cm6s8szdz0001lgt40msjbqsi.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>I2C也是通讯中常采用的手段之一，和串口有所同，也有所不同。</p></blockquote><h1 id="I2C简介"><a href="#I2C简介" class="headerlink" title="I2C简介"></a>I2C简介</h1><ol><li><p>I2C（Inter IC Bus）是由Philips公司开发的一种通用数据总线</p></li><li><p>两根通信线：SCL（Serial Clock）、SDA（Serial Data）</p></li><li><p>同步，半双工</p></li><li><p>带数据应答支持总线挂载多设备（一主多从、多主多从）</p></li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> Stm32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stm32 </tag>
            
            <tag> 单片机开发 </tag>
            
            <tag> I2C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stm32之USART串口</title>
      <link href="/cm6s8sze00002lgt41hv7172k.html"/>
      <url>/cm6s8sze00002lgt41hv7172k.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在单片机的应用中，通讯是必不可少的，通过通讯能够收发数据，进而对数据进行处理，进而生成控制指令，或者单纯用来调试，也是非常不错的选择。</p></blockquote><h1 id="通信接口"><a href="#通信接口" class="headerlink" title="通信接口"></a>通信接口</h1><ul><li><p>通信的目的：将一个设备的数据传送到另一个设备，扩展硬件系统</p></li><li><p>通信协议：制定通信的规则，通信双方按照协议规则进行数据收发</p></li></ul><p><img src="/cm6pzvpe300018kt42rjib049/T%E4%B8%B2%E5%8F%A3/image-20250205143915034.png" alt="image-20250205143915034"></p><blockquote><p>除上面指出的全双工和半双工之外，还有单工，指的是只能从将数据从一处传输至另一处，是单向的。</p></blockquote><blockquote><p>单端信号需要共地。</p></blockquote><h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><ul><li><p>串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信</p></li><li><p>单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大地扩展了单片机的应用范围，增强了单片机系统的硬件实力</p></li></ul><h1 id="电平标准"><a href="#电平标准" class="headerlink" title="电平标准"></a>电平标准</h1><p>电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：</p><ol><li><p>TTL电平：<strong>+3.3V</strong> 或 <strong>+5V</strong> 表示 <strong>1</strong> ，<strong>0V</strong> 表示 <strong>0</strong></p></li><li><p>RS232电平：<strong>-3 <strong>~ <strong>-15V</strong>表示 <strong>1</strong>，</strong>+3</strong> ~ **+15V **表示 <strong>0</strong></p></li><li><p>RS485电平：两线压差 <strong>+2</strong> ~ <strong>+6V</strong> 表示 <strong>1</strong>，<strong>-2</strong> ~ **-6V ** 表示 <strong>0</strong>（差分信号）</p></li></ol><h1 id="串口参数及时序"><a href="#串口参数及时序" class="headerlink" title="串口参数及时序"></a>串口参数及时序</h1><ul><li><p>波特率：串口通信的速率</p></li><li><p>起始位：标志一个数据帧的开始，固定为低电平</p></li><li><p>数据位：数据帧的有效载荷，1为高电平，0为低电平，<strong>低位先行</strong></p></li><li><p>校验位：用于数据验证，根据数据位计算得来</p></li><li><p>停止位：用于数据帧间隔，固定为高电平</p></li></ul><p><img src="/cm6pzvpe300018kt42rjib049/T%E4%B8%B2%E5%8F%A3/image-20250205192550058.png" alt="image-20250205192550058"></p><h1 id="USART简介"><a href="#USART简介" class="headerlink" title="USART简介"></a>USART简介</h1><ol><li><p>USART（Universal Synchronous&#x2F;Asynchronous Receiver&#x2F;Transmitter）通用同步&#x2F;异步收发器</p></li><li><p>USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里</p></li><li><p>自带波特率发生器，最高达4.5Mbits&#x2F;s</p></li><li><p>可配置数据位长度（8&#x2F;9）、停止位长度（0.5&#x2F;1&#x2F;1.5&#x2F;2）</p></li><li><p>可选校验位（无校验&#x2F;奇校验&#x2F;偶校验）</p></li><li><p>支持同步模式、硬件流控制、DMA、智能卡、IrDA、LIN</p></li><li><p>STM32F103C8T6 USART资源： USART1、 USART2、 USART3</p></li></ol><h1 id="USART框图"><a href="#USART框图" class="headerlink" title="USART框图"></a>USART框图</h1><p><img src="/cm6pzvpe300018kt42rjib049/T%E4%B8%B2%E5%8F%A3/image-20250205192729415.png" alt="image-20250205192729415"></p><blockquote><p>注意：USART的TDR和RDR两个寄存器在程序上只表现为一个寄存器（DR），但在实际硬件电路中有两个，一个只写，一个只读。</p></blockquote><h1 id="USART基本结构"><a href="#USART基本结构" class="headerlink" title="USART基本结构"></a>USART基本结构</h1><p><img src="/cm6pzvpe300018kt42rjib049/T%E4%B8%B2%E5%8F%A3/image-20250205192758875.png" alt="image-20250205192758875"></p><h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串口接收+发送 程序代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化串口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//开启时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GPIO配置 PA9</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PA10</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//USART初始化</span></span><br><span class="line">    USART_InitTypeDef USART_InitStructure;</span><br><span class="line">    USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;<span class="comment">//波特率</span></span><br><span class="line">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;<span class="comment">//不使用硬件流控制</span></span><br><span class="line">    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;<span class="comment">//模式：发送和接收</span></span><br><span class="line">    USART_InitStructure.USART_Parity = USART_Parity_No;<span class="comment">//校验位：无</span></span><br><span class="line">    USART_InitStructure.USART_StopBits = USART_StopBits_1;<span class="comment">//停止位：1</span></span><br><span class="line">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;<span class="comment">//长度：8</span></span><br><span class="line">    USART_Init(USART1, &amp;USART_InitStructure);</span><br><span class="line">    </span><br><span class="line">    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);<span class="comment">//开启USART1中断</span></span><br><span class="line">    </span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//NVIC配置</span></span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">    </span><br><span class="line">    USART_Cmd(USART1, ENABLE);<span class="comment">//开启串口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">    USART_SendData(USART1, Byte);</span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial_SendByte(Array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; String[i] != <span class="string">&#x27;\0&#x27;</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial_SendByte(String[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//次方函数</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Y --)</span><br><span class="line">    &#123;</span><br><span class="line">        Result *= X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number, <span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial_SendByte(Number / Serial_Pow(<span class="number">10</span>, Length - i - <span class="number">1</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向printf函数，记得勾选MicroLIB</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    Serial_SendByte(ch);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对sprintf函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">    va_list arg;</span><br><span class="line">    va_start(arg, format);</span><br><span class="line">    <span class="built_in">vsprintf</span>(String, format, arg);</span><br><span class="line">    va_end(arg);</span><br><span class="line">    Serial_SendString(String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Serial_RxData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">        Serial_RxFlag = <span class="number">1</span>;</span><br><span class="line">        USART_ClearITPendingBit(USART1, USART_IT_RXNE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h1><ol><li>HEX数据包<ul><li>固定包长</li><li>可变包长</li></ul></li><li>文本数据包<ul><li>固定包长</li><li>可变包长</li></ul></li></ol><h1 id="HEX数据包接收"><a href="#HEX数据包接收" class="headerlink" title="HEX数据包接收"></a>HEX数据包接收</h1><p><img src="/cm6pzvpe300018kt42rjib049/T%E4%B8%B2%E5%8F%A3/image-20250206135407009.png" alt="image-20250206135407009"></p><h1 id="文本数据包接收"><a href="#文本数据包接收" class="headerlink" title="文本数据包接收"></a>文本数据包接收</h1><p><img src="/cm6pzvpe300018kt42rjib049/T%E4%B8%B2%E5%8F%A3/image-20250206135427856.png" alt="image-20250206135427856"></p><h1 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//中断函数内处理接收到的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//static关键字可以使得变量在函数运行完之后不被销毁，改变生命周期，不改变作用域</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;<span class="comment">//状态</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> pRxPacket = <span class="number">0</span>;<span class="comment">//收集数据个数</span></span><br><span class="line">    <span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)<span class="comment">//RX非空：可读</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);<span class="comment">//读取数据</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (RxState == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (RxData == <span class="string">&#x27;@&#x27;</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                RxState = <span class="number">1</span>;</span><br><span class="line">                pRxPacket = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (RxData == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                RxState = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Serial_RxPacket[pRxPacket] = RxData;</span><br><span class="line">                pRxPacket ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (RxData == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                RxState = <span class="number">0</span>;</span><br><span class="line">                Serial_RxPacket[pRxPacket] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                Serial_RxFlag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        USART_ClearITPendingBit(USART1, USART_IT_RXNE);<span class="comment">//清除标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      <categories>
          
          <category> Stm32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stm32 </tag>
            
            <tag> 单片机开发 </tag>
            
            <tag> USART </tag>
            
            <tag> 串口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stm32之ADC</title>
      <link href="/cm6pzvpe300018kt42rjib049.html"/>
      <url>/cm6pzvpe300018kt42rjib049.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章主要介绍ADC模数转换器及DMA转运，这也是Stm32中比较重要的部分，值得大家学习。</p></blockquote><h1 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h1><ol><li><p>ADC（Analog-Digital Converter）模拟-数字转换器</p></li><li><p>ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁</p></li><li><p>12位逐次逼近型ADC，1us转换时间</p></li><li><p>输入电压范围：0~3.3V，转换结果范围：0~4095</p></li><li><p>18个输入通道，可测量16个外部和2个内部信号源</p></li><li><p>规则组和注入组两个转换单元</p></li><li><p>模拟看门狗自动监测输入电压范围</p></li><li><p>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p></li></ol><h1 id="逐次逼近型ADC"><a href="#逐次逼近型ADC" class="headerlink" title="逐次逼近型ADC"></a>逐次逼近型ADC</h1><p><img src="/cm6pzvpe300018kt42rjib049/image-20250204182838805.png" alt="image-20250204182838805"></p><h1 id="ADC框图"><a href="#ADC框图" class="headerlink" title="ADC框图"></a>ADC框图</h1><p><img src="/cm6pzvpe300018kt42rjib049/image-20250204183258498.png" alt="image-20250204183258498"></p><h1 id="ADC基本结构"><a href="#ADC基本结构" class="headerlink" title="ADC基本结构"></a>ADC基本结构</h1><p><img src="/cm6pzvpe300018kt42rjib049/image-20250204182934280.png" alt="image-20250204182934280"></p><blockquote><p>注意：规则组可以采集16路通道，但是只能保持一路通道采集信息，一般配合DMA转运进行使用；而注入组AD数据寄存器完全可以将它能采集到的４路通道信息同时保存。</p></blockquote><h1 id="转换模式"><a href="#转换模式" class="headerlink" title="转换模式"></a>转换模式</h1><p>根据选择单次转换还是连续转换,扫描还是非扫描,有以下4种转换模式:</p><ol><li>单次转换，非扫描模式</li><li>连续转换，非扫描模式</li><li>单次转换，扫描模式</li><li>连续转换，扫描模式</li></ol><blockquote><p>如果不扫描，则只检测第一个通道(指定的)，如果扫描，则会按照指定的顺序对通道进行检测，在检测完成之后，会将EOC置1；如果选择的是单次转换，在一次转换完成后就停止，直至下一次发送检测指令，选择连续，则会一直检测下去。</p></blockquote><blockquote><p>当然，在扫描模式下，还有间断模式，详见STM32参考手册。</p></blockquote><h1 id="ADC触发源"><a href="#ADC触发源" class="headerlink" title="ADC触发源"></a>ADC触发源</h1><p>下表是STM32C8T6中ADC1和ADC2用于规则通道的外部触发：</p><table><thead><tr><th align="center">触发源</th><th align="center">类型</th><th align="center">EXTSEL[2:0]</th></tr></thead><tbody><tr><td align="center">TIM1_CC1事件</td><td align="center">来自片上定时器的内部信号</td><td align="center">000</td></tr><tr><td align="center">TIM1_CC2事件</td><td align="center">来自片上定时器的内部信号</td><td align="center">001</td></tr><tr><td align="center">TIM1_CC3事件</td><td align="center">来自片上定时器的内部信号</td><td align="center">010</td></tr><tr><td align="center">TIM2_CC2事件</td><td align="center">来自片上定时器的内部信号</td><td align="center">011</td></tr><tr><td align="center">TIM3_TRGO事件</td><td align="center">来自片上定时器的内部信号</td><td align="center">100</td></tr><tr><td align="center">TIM4_CC4事件</td><td align="center">来自片上定时器的内部信号</td><td align="center">101</td></tr><tr><td align="center">EXTI线11&#x2F;TIM8_TRGO事件</td><td align="center">外部引脚&#x2F;来自片上定时器的内部信号</td><td align="center">110</td></tr><tr><td align="center">SWSTART</td><td align="center">软件控制位</td><td align="center">111</td></tr></tbody></table><h1 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h1><ol><li>数据右对齐：</li></ol><p><img src="/cm6pzvpe300018kt42rjib049/image-20250204203930347.png" alt="image-20250204203930347"></p><ol start="2"><li>数据左对齐：</li></ol><p><img src="/cm6pzvpe300018kt42rjib049/image-20250204203811983.png" alt="image-20250204203811983"></p><blockquote><p>选择左对齐的好处：可以选择取出高八位，降低精度。</p></blockquote><h1 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h1><ul><li><p>AD转换的步骤：采样，保持，量化，编码</p></li><li><p>STM32 ADC的总转换时间为：$T_{CONV}$ &#x3D; 采样时间 + 12.5个ADC周期</p></li><li><p>例如：当ADCCLK&#x3D;14MHz，采样时间为1.5个ADC周期；$T_{CONV}$​ &#x3D; 1.5 + 12.5 &#x3D; 14个ADC周期 &#x3D; 1μs</p></li></ul><h1 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h1><ul><li><p>ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差</p></li><li><p>建议在每次上电后执行一次校准</p></li><li><p>启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期</p></li></ul><h1 id="ADC外围硬件电路设计"><a href="#ADC外围硬件电路设计" class="headerlink" title="ADC外围硬件电路设计"></a>ADC外围硬件电路设计</h1><p><img src="/cm6pzvpe300018kt42rjib049/image-20250204210704123.png" alt="image-20250204210704123"></p><h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AD多通道</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//时钟配置</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC时钟分频设置，注意：最大14MHz，故选择6分频，也就是72/6=12MHz</span></span><br><span class="line">    RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GPIO配置</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC配置</span></span><br><span class="line">    ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;<span class="comment">//工作模式：独立模式</span></span><br><span class="line">    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//数据对齐</span></span><br><span class="line">    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;<span class="comment">//外部触发源：内部触发/软件触发</span></span><br><span class="line">    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;<span class="comment">//连续or单次转换</span></span><br><span class="line">    ADC_InitStructure.ADC_ScanConvMode = DISABLE;<span class="comment">//扫描or非扫描</span></span><br><span class="line">    ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;<span class="comment">//扫描模式下用到？个通道</span></span><br><span class="line">    ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line">    </span><br><span class="line">    ADC_Cmd(ADC1, ENABLE);<span class="comment">//开启ADC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC校准</span></span><br><span class="line">    ADC_ResetCalibration(ADC1);<span class="comment">//复位校准</span></span><br><span class="line">    <span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);<span class="comment">//返回 复位校准 的状态</span></span><br><span class="line">    ADC_StartCalibration(ADC1);<span class="comment">//开始校准</span></span><br><span class="line">    <span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);<span class="comment">//等待校准完成</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">uint8_t</span> ADC_Channel)</span></span><br><span class="line">&#123;</span><br><span class="line">    ADC_RegularChannelConfig(ADC1, ADC_Channel, <span class="number">1</span>, ADC_SampleTime_55Cycles5);<span class="comment">//指定通道</span></span><br><span class="line">    ADC_SoftwareStartConvCmd(ADC1, ENABLE);<span class="comment">//软件触发转换</span></span><br><span class="line">    <span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);<span class="comment">//等待转换完成</span></span><br><span class="line">    <span class="keyword">return</span> ADC_GetConversionValue(ADC1);<span class="comment">//返回测得值并且会 自动 清除标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a>DMA简介</h1><ol><li><p>DMA（Direct Memory Access）直接存储器存取</p></li><li><p>DMA可以提供外设和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源</p></li><li><p>12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）</p></li><li><p>每个通道都支持软件触发和特定的硬件触发</p></li><li><p>STM32F103C8T6 DMA资源：DMA1（7个通道）</p></li></ol><h1 id="存储器映像"><a href="#存储器映像" class="headerlink" title="存储器映像"></a>存储器映像</h1><p><img src="/cm6pzvpe300018kt42rjib049/image-20250205012732409.png" alt="image-20250205012732409"></p><h1 id="DMA框图"><a href="#DMA框图" class="headerlink" title="DMA框图"></a>DMA框图</h1><p><img src="/cm6pzvpe300018kt42rjib049/image-20250205012752788.png" alt="image-20250205012752788"></p><h1 id="DMA基本结构"><a href="#DMA基本结构" class="headerlink" title="DMA基本结构"></a>DMA基本结构</h1><p><img src="/cm6pzvpe300018kt42rjib049/image-20250205012812533.png" alt="image-20250205012812533"></p><h1 id="DMA请求"><a href="#DMA请求" class="headerlink" title="DMA请求"></a>DMA请求</h1><p><img src="/cm6pzvpe300018kt42rjib049/image-20250205012834903.png" alt="image-20250205012834903"></p><h1 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运+DMA"></a>数据转运+DMA</h1><p><img src="/cm6pzvpe300018kt42rjib049/image-20250205012903786.png" alt="image-20250205012903786"></p><blockquote><p>DMA转运一轮后必须 关闭 DMA后再开启。</p></blockquote><h1 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DMA转运</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> AddrA, <span class="type">uint32_t</span> AddrB, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyDMA_Size = Size;</span><br><span class="line">    </span><br><span class="line">    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);<span class="comment">//开启时钟，DMA是AHB的外设</span></span><br><span class="line">    </span><br><span class="line">    DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">    DMA_InitStructure.DMA_PeripheralBaseAddr = AddrA;<span class="comment">//外设基地址</span></span><br><span class="line">    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;<span class="comment">//数据宽度</span></span><br><span class="line">    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;<span class="comment">//是否自增</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryBaseAddr = AddrB;<span class="comment">//储存器基地址</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;<span class="comment">//储存器数据宽度</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//是否自增</span></span><br><span class="line">    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="comment">//转运方向</span></span><br><span class="line">    DMA_InitStructure.DMA_BufferSize = Size;<span class="comment">//缓存区大小：传输计数器</span></span><br><span class="line">    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;<span class="comment">//传输模式：是否使用自动重装</span></span><br><span class="line">    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;<span class="comment">//选择硬件触发还是软件触发</span></span><br><span class="line">    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;<span class="comment">//优先级设置</span></span><br><span class="line">    DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);<span class="comment">//配置到通道1</span></span><br><span class="line">    </span><br><span class="line">    DMA_Cmd(DMA1_Channel1, DISABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMA_Cmd(DMA1_Channel1, DISABLE);</span><br><span class="line">    DMA_SetCurrDataCounter(DMA1_Channel1, MyDMA_Size);</span><br><span class="line">    DMA_Cmd(DMA1_Channel1, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">    DMA_ClearFlag(DMA1_FLAG_TC1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式+DMA"></a>ADC扫描模式+DMA</h1><p><img src="/cm6pzvpe300018kt42rjib049/image-20250205012933008.png" alt="image-20250205012933008"></p><h1 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ADC扫描模式+DMA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD_Value[<span class="number">4</span>];<span class="comment">//SRAM 数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//开启时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC时钟分频：12MHz</span></span><br><span class="line">    RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GPIO配置</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC通道配置</span></span><br><span class="line">    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">    ADC_RegularChannelConfig(ADC1, ADC_Channel_1, <span class="number">2</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">    ADC_RegularChannelConfig(ADC1, ADC_Channel_2, <span class="number">3</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">    ADC_RegularChannelConfig(ADC1, ADC_Channel_3, <span class="number">4</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC初始化</span></span><br><span class="line">    ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;<span class="comment">//独立模式</span></span><br><span class="line">    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;<span class="comment">//右对齐</span></span><br><span class="line">    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;<span class="comment">//软件触发</span></span><br><span class="line">    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;<span class="comment">//连续模式</span></span><br><span class="line">    ADC_InitStructure.ADC_ScanConvMode = ENABLE;<span class="comment">//扫描模式</span></span><br><span class="line">    ADC_InitStructure.ADC_NbrOfChannel = <span class="number">4</span>;<span class="comment">//使用通道数目</span></span><br><span class="line">    ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//DMA初始化</span></span><br><span class="line">    DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">    DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;<span class="comment">//外设地址：ADC1</span></span><br><span class="line">    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;<span class="comment">//数据宽度：半字节</span></span><br><span class="line">    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<span class="comment">//自增：关闭</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)AD_Value;<span class="comment">//储存器地址</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;<span class="comment">//数据宽度：半字节</span></span><br><span class="line">    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;<span class="comment">//自增：开启</span></span><br><span class="line">    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;<span class="comment">//方向：外设-&gt;储存器</span></span><br><span class="line">    DMA_InitStructure.DMA_BufferSize = <span class="number">4</span>;<span class="comment">//传输计数器</span></span><br><span class="line">    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;<span class="comment">//自动重装器：启用</span></span><br><span class="line">    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;<span class="comment">//硬件触发</span></span><br><span class="line">    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;<span class="comment">//优先级：中</span></span><br><span class="line">    DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);<span class="comment">//选择通道1</span></span><br><span class="line">    </span><br><span class="line">    DMA_Cmd(DMA1_Channel1, ENABLE);<span class="comment">//开启DMA</span></span><br><span class="line">    ADC_DMACmd(ADC1, ENABLE);<span class="comment">//开启ADC的DMA触发信号</span></span><br><span class="line">    ADC_Cmd(ADC1, ENABLE);<span class="comment">//开启ADC</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ADC复位</span></span><br><span class="line">    ADC_ResetCalibration(ADC1);</span><br><span class="line">    <span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">    ADC_StartCalibration(ADC1);</span><br><span class="line">    <span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);</span><br><span class="line">    </span><br><span class="line">    ADC_SoftwareStartConvCmd(ADC1, ENABLE);<span class="comment">//触发ADC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      <categories>
          
          <category> Stm32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stm32 </tag>
            
            <tag> ADC </tag>
            
            <tag> 单片机开发 </tag>
            
            <tag> DMA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp学习</title>
      <link href="/cm6pzvpec000l8kt4506w08hy.html"/>
      <url>/cm6pzvpec000l8kt4506w08hy.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> cpp基础学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stm32之定时器</title>
      <link href="/cm6pzvpeb000i8kt447sf0uuz.html"/>
      <url>/cm6pzvpeb000i8kt447sf0uuz.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Stm32中定时器的使用无疑是至关重要的，通过使用定时器可以使我们的流程控制更加简单可控，还可以使我们的代码模块化，方便管理与调试。Stm32的定时器的使用分为定时中断、输出比较、输入捕获、编码器接口这几个主要部分，下面一一来介绍。</p></blockquote><h1 id="定时器框图"><a href="#定时器框图" class="headerlink" title="定时器框图"></a>定时器框图</h1><p><img src="/cm6pzvpeb000i8kt447sf0uuz/image-20250201222055382.png" alt="image-20250201222055382"></p><h1 id="定时中断"><a href="#定时中断" class="headerlink" title="定时中断"></a>定时中断</h1><h2 id="定时中断基本结构"><a href="#定时中断基本结构" class="headerlink" title="定时中断基本结构"></a>定时中断基本结构</h2><p><img src="/cm6pzvpeb000i8kt447sf0uuz/image-20250201222255621.png" alt="image-20250201222255621"></p><h2 id="影子寄存器"><a href="#影子寄存器" class="headerlink" title="影子寄存器"></a>影子寄存器</h2><p>影子寄存器：在改变自动重装寄存器TIMx_ARR时，若开启影子寄存器，该寄存器中的值不会立即更新，而是会在产生又一个更新事件后，更新该寄存器中的值，可以防止某些意外情况的发生。比如，初始ARR的值为5，当计数器中的值为4时更改ARR为3，此时4 &gt;3，但是不等于3，随着时间的增加，计数器中的值只会在超出计数器计数上限时溢出，当计数器中的值再次等于3时才会产生一次更新事件。</p><h2 id="计数器溢出频率"><a href="#计数器溢出频率" class="headerlink" title="计数器溢出频率"></a>计数器溢出频率</h2><p><strong>计数器溢出频率</strong>：CK_CNT_OV &#x3D; CK_CNT &#x2F; (ARR + 1)  &#x3D; CK_PSC &#x2F; (PSC + 1) &#x2F; (ARR + 1)</p><h2 id="定时器中断代码演示"><a href="#定时器中断代码演示" class="headerlink" title="定时器中断代码演示"></a>定时器中断代码演示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); <span class="comment">//开启时钟</span></span><br><span class="line">    </span><br><span class="line">    TIM_InternalClockConfig(TIM2); <span class="comment">//设置时钟源</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//时基单元设置</span></span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<span class="comment">//分频系数</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数模式</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span> - <span class="number">1</span>;<span class="comment">//ARR</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span> - <span class="number">1</span>;<span class="comment">//psc</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//RCR,仅高级定时器才有</span></span><br><span class="line">    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">    </span><br><span class="line">    TIM_ClearFlag(TIM2, TIM_FLAG_Update);<span class="comment">//清除标志位</span></span><br><span class="line">    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);<span class="comment">//定时器中断使能</span></span><br><span class="line">    </span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//NVIC分组，全局仅需配置一次</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//NVIC</span></span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;<span class="comment">//抢占优先级</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;<span class="comment">//响应优先级</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">    </span><br><span class="line">    TIM_Cmd(TIM2, ENABLE);<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)</span><br><span class="line">    &#123;</span><br><span class="line">        Num ++;</span><br><span class="line">        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一般情况下的定时中断配置步骤"><a href="#一般情况下的定时中断配置步骤" class="headerlink" title="一般情况下的定时中断配置步骤"></a>一般情况下的定时中断配置步骤</h2><ol><li>开启时钟；</li><li>选择时钟源；</li><li>配置时基单元；</li><li>中断配置；</li><li>NVIC优先级配置；</li><li>中断函数编写。</li></ol><h2 id="关于时钟源的选择"><a href="#关于时钟源的选择" class="headerlink" title="关于时钟源的选择"></a>关于时钟源的选择</h2><ol><li><p>内部时钟模式</p><ul><li>RCC内部时钟</li></ul></li><li><p>外部时钟模式2</p><ul><li>ETR外部时钟：使用外部触发输入（ETR）作为时钟源</li></ul></li><li><p>外部时钟模式1</p><ul><li>ETR外部时钟</li><li>ITRx其他定时器</li><li>TIx捕获通道</li></ul></li><li><p>编码器模式</p><ul><li>TIx捕获通道</li></ul></li></ol><h1 id="输出比较"><a href="#输出比较" class="headerlink" title="输出比较"></a>输出比较</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p>OC（Output Compare）输出比较输出比较</p></li><li><p>可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形</p></li><li><p>每个高级定时器和通用定时器都拥有4个输出比较通道</p></li><li><p>高级定时器的前3个通道额外拥有死区生成和互补输出的功能</p></li></ul><h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><ul><li><p>PWM（Pulse Width Modulation）脉冲宽度调制</p></li><li><p>在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域</p></li><li><p>PWM参数：     </p><ol><li><p>频率 &#x3D; $\frac{1}{T_{s}}$         </p></li><li><p>占空比 &#x3D;   $\frac{T_{ON}}{T_{S}}$</p></li><li><p>分辨率 &#x3D; 占空比变化步距</p></li></ol></li></ul><h2 id="输出比较代码演示"><a href="#输出比较代码演示" class="headerlink" title="输出比较代码演示"></a>输出比较代码演示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//开启时钟</span></span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); //AFIO时钟开启</span></span><br><span class="line"><span class="comment">//    GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);//重映射</span></span><br><span class="line"><span class="comment">//    GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);//解除调试端口占用</span></span><br><span class="line">    </span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<span class="comment">//GPIO_Pin_15;</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//选择时钟源：内部时钟源:72MHz</span></span><br><span class="line">    TIM_InternalClockConfig(TIM2);</span><br><span class="line">    </span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<span class="comment">//向上计数</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;<span class="comment">//ARR</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span> - <span class="number">1</span>;<span class="comment">//PSC</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;<span class="comment">//RCR</span></span><br><span class="line">    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出比较配置</span></span><br><span class="line">    TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">    TIM_OCStructInit(&amp;TIM_OCInitStructure);</span><br><span class="line">    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;<span class="comment">//模式:PWM1，CNT&lt;CCR时高电平，CNT&gt;CCR时低电平</span></span><br><span class="line">    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;<span class="comment">//极性选择</span></span><br><span class="line">    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;<span class="comment">//使能</span></span><br><span class="line">    TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;<span class="comment">//CCR 捕获/比较寄存器</span></span><br><span class="line">    TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);<span class="comment">//通道1初始化</span></span><br><span class="line">    </span><br><span class="line">    TIM_Cmd(TIM2, ENABLE);<span class="comment">//开启定时器TIM2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare1</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM_SetCompare1(TIM2, Compare);<span class="comment">//更改CCR寄存器值：通道1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意：使用高级定时器输出PWM时需要调用TIM_CtrlPWMOutputs()函数，否则不能正常输出。</p></blockquote><h1 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h1><blockquote><p>对于同一个定时器<strong>输入捕获</strong>和<strong>输出比较</strong>只能使用其中一个。</p></blockquote><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul><li><p>IC（Input Capture）输入捕获</p></li><li><p>输入捕获模式下，当通道输入引脚出现指定<strong>电平跳变</strong>时，当前<strong>CNT</strong>的值将被锁存到<strong>CCR</strong>中，可用于测量<strong>PWM</strong>波形的频率、占空比、脉冲间隔、电平持续时间等参数</p></li><li><p>每个高级定时器和通用定时器都拥有4个输入捕获通道</p></li><li><p>可配置为PWMI模式，同时测量频率和占空比</p></li><li><p>可配合主从触发模式，实现硬件全自动测量</p></li></ul><h2 id="频率测量"><a href="#频率测量" class="headerlink" title="频率测量"></a>频率测量</h2><ol><li><p>测频法：在闸门时间T内，对上升沿计次，得到N，则频率$f_{x} &#x3D; \frac{N}{T}$</p></li><li><p>测周法：两个上升沿内，以标准频率fc计次，得到N，则频率$f_x &#x3D; \frac{f_{c}}{N}$</p></li><li><p>中界频率：测频法与测周法误差相等的频率点$f_{m}&#x3D;\frac{\sqrt{f_{c}}}{T}$</p></li></ol><h2 id="输入捕获通道"><a href="#输入捕获通道" class="headerlink" title="输入捕获通道"></a>输入捕获通道</h2><p><img src="/cm6pzvpeb000i8kt447sf0uuz/image-20250203171218877.png" alt="image-20250203171218877"></p><h2 id="主从触发模式"><a href="#主从触发模式" class="headerlink" title="主从触发模式"></a>主从触发模式</h2><p><img src="/cm6pzvpeb000i8kt447sf0uuz/image-20250203171253977.png" alt="image-20250203171253977"></p><h2 id="输入捕获基本结构"><a href="#输入捕获基本结构" class="headerlink" title="输入捕获基本结构"></a>输入捕获基本结构</h2><p><img src="/cm6pzvpeb000i8kt447sf0uuz/image-20250203171331674.png" alt="image-20250203171331674"></p><h2 id="PWMI结构"><a href="#PWMI结构" class="headerlink" title="PWMI结构"></a>PWMI结构</h2><p><img src="/cm6pzvpeb000i8kt447sf0uuz/image-20250203171359863.png" alt="image-20250203171359863"></p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//开启时钟</span></span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GPIO配置</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//选择时钟源</span></span><br><span class="line">    TIM_InternalClockConfig(TIM3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//时基单元</span></span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;<span class="comment">//ARR</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;<span class="comment">//PSC</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输入捕获配置</span></span><br><span class="line">    TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;<span class="comment">//通道</span></span><br><span class="line">    TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;<span class="comment">//滤波器</span></span><br><span class="line">    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;<span class="comment">//极性选择:上升沿触发</span></span><br><span class="line">    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;<span class="comment">//预分频</span></span><br><span class="line">    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;<span class="comment">//直连通道</span></span><br><span class="line">    TIM_PWMIConfig(TIM3, &amp;TIM_ICInitStructure);<span class="comment">//该函数能自动把对应的另一个通道配置成下降沿触发、交叉通道</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从模式</span></span><br><span class="line">    TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);<span class="comment">//触发源选择</span></span><br><span class="line">    TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);<span class="comment">//从模式选择:Reset模式</span></span><br><span class="line">    </span><br><span class="line">    TIM_Cmd(TIM3, ENABLE);<span class="comment">//开启定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><ul><li><p>Encoder Interface 编码器接口</p></li><li><p>编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p></li><li><p>每个高级定时器和通用定时器都拥有1个编码器接口</p></li><li><p>两个输入引脚借用了输入捕获的通道1和通道2</p></li></ul><h2 id="正交编码器"><a href="#正交编码器" class="headerlink" title="正交编码器"></a>正交编码器</h2><p><img src="/cm6pzvpeb000i8kt447sf0uuz/image-20250203171631395.png" alt="image-20250203171631395"></p><h2 id="编码器接口基本结构"><a href="#编码器接口基本结构" class="headerlink" title="编码器接口基本结构"></a>编码器接口基本结构</h2><p><img src="/cm6pzvpeb000i8kt447sf0uuz/image-20250203171702111.png" alt="image-20250203171702111"></p><h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    \\开启时钟</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    </span><br><span class="line">    \\GPIO配置</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">        </span><br><span class="line">    \\时基单元</span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;<span class="comment">//ARR</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span> - <span class="number">1</span>;<span class="comment">//PSC</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">    </span><br><span class="line">    \\输入捕获配置</span><br><span class="line">    TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">    TIM_ICStructInit(&amp;TIM_ICInitStructure);</span><br><span class="line">    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">    TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">    TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line">    TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;</span><br><span class="line">    TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">    TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line">    </span><br><span class="line">    \\编码器接口</span><br><span class="line">    TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);</span><br><span class="line">    </span><br><span class="line">    TIM_Cmd(TIM3, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      <categories>
          
          <category> Stm32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stm32 </tag>
            
            <tag> 单片机开发 </tag>
            
            <tag> 定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基础语法</title>
      <link href="/cm6pzvpea000h8kt44xz8enwm.html"/>
      <url>/cm6pzvpea000h8kt44xz8enwm.html</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>Markdown 使用 # 符号来表示标题，支持六级标题， # 的数量代表标题的级别。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题 </span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题 </span></span><br><span class="line"><span class="section">#### 四级标题 </span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h1 id="段落与书写"><a href="#段落与书写" class="headerlink" title="段落与书写"></a>段落与书写</h1><p>这是一段文字，行尾+两个空格换行。    </p><p>这是第二段文字·····</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一段文字，行尾+两个空格换行。  </span><br><span class="line">这是第二段文字·····  </span><br></pre></td></tr></table></figure><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span> 或 <span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**加粗**</span> 或 <span class="strong">__加粗__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*斜体+加粗*</span>**</span> 或 <span class="strong">__<span class="emphasis">_斜体+加粗_</span>__</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><em>斜体</em> 或 <em>斜体</em><br><strong>加粗</strong> 或 <strong>加粗</strong><br><em><strong>斜体+加粗</strong></em> 或 <em><strong>斜体+加粗</strong></em></p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>Markdown支持无序列表和有序列表。</p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 项目一</span><br><span class="line"><span class="bullet">-</span> 项目二</span><br><span class="line"><span class="bullet">  -</span> 子项目一</span><br><span class="line"><span class="bullet">  -</span> 子项目二</span><br><span class="line"><span class="bullet">*</span> 项目三</span><br></pre></td></tr></table></figure><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 项目一</span><br><span class="line"><span class="bullet">2.</span> 项目二</span><br><span class="line"><span class="bullet">  1.</span> 子项目一</span><br><span class="line"><span class="bullet">  2.</span> 子项目二</span><br></pre></td></tr></table></figure><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Google</span>](<span class="link">http://www.google.com</span>)</span><br></pre></td></tr></table></figure><p>效果： <a href="http://www.google.com/">Google</a></p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>在Typora中可以直接将图片拖进来并自动复制至相应文件夹，其余方法不做演示。</p><p><img src="/cm6pzvpea000h8kt44xz8enwm/Sky_3.jpg" alt="Sky_3"></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用使用 “&gt;” 进行标记，支持嵌套引用。 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个引用。</span></span><br><span class="line">&gt;&gt; 这是嵌套引用。</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><blockquote><p>这是一个引用。</p><blockquote><p>这是嵌套引用。</p></blockquote></blockquote><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>⾏内代码：⽤反引号（&#96;&#96;）包裹。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是 <span class="code">`行内代码`</span> 示例。</span><br></pre></td></tr></table></figure><p>效果：</p><p>这是 <code>行内代码</code> 示例。</p><p>代码块：⽤三个反引号（`&#96;&#96;）包裹，⽀持指定语⾔类型。 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```python </span></span><br><span class="line"><span class="code">def hello(): </span></span><br><span class="line"><span class="code">    print(&quot;Hello, Markdown!&quot;) </span></span><br></pre></td></tr></table></figure><p>效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(): </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, Markdown!&quot;</span>) </span><br></pre></td></tr></table></figure><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>使用 | 和 - 创建表格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 表头1 | 表头2 | 表头3 | </span><br><span class="line">|-------|-------|-------|</span><br><span class="line">| 数据1 | 数据2 | 数据3 |</span><br><span class="line">| 数据4 | 数据5 | 数据6 |</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th>表头1</th><th>表头2</th><th>表头3</th></tr></thead><tbody><tr><td>数据1</td><td>数据2</td><td>数据3</td></tr><tr><td>数据4</td><td>数据5</td><td>数据6</td></tr></tbody></table><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>使用三个或更多的 - 、 * 或 _ 创建分隔线。 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- </span><br><span class="line"><span class="strong">*** </span></span><br><span class="line"><span class="strong">__<span class="emphasis">_</span></span></span><br></pre></td></tr></table></figure><p>效果：</p><hr><h1 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h1><p>使用 - [ ] 创建未完成任务， - [x] 创建已完成任务。 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 任务一 </span><br><span class="line"><span class="bullet">-</span> [x] 任务二 </span><br><span class="line"><span class="bullet">-</span> [ ] 任务三</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><input disabled="" type="checkbox"> 任务一 </li><li><input checked="" disabled="" type="checkbox"> 任务二 </li><li><input disabled="" type="checkbox"> 任务三</li></ul><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\frac&#123;a&#125;&#123;b&#125;$</span><br></pre></td></tr></table></figure><p>效果：$\frac{a}{b}$</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown&#39;s Grammar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/cm6pzvped000m8kt4dso88bht.html"/>
      <url>/cm6pzvped000m8kt4dso88bht.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
